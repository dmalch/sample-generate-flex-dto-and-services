<%
    Set as3Imports = new TreeSet();

    as3Imports.add("mx.messaging.ChannelSet");
    as3Imports.add("mx.messaging.config.ServerConfig");
    as3Imports.add("mx.rpc.AsyncToken");
    as3Imports.add("mx.rpc.IResponder");
    as3Imports.add("mx.logging.ILogger");
    as3Imports.add("mx.logging.Log");
    as3Imports.add("flash.utils.getQualifiedClassName");

    if (!jClass.hasSuperclass())
        as3Imports.add("mx.rpc.remoting.mxml.RemoteObject");


    for (jImport in jClass.imports) {
        if (jImport.as3Type.hasPackage() && jImport.as3Type.packageName != jClass.as3Type.packageName)
            as3Imports.add(jImport.as3Type.qualifiedName);
    }

%>/**
 * Generated by Gas3 v${gVersion} (Granite Data Services).
 *
 * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE
 * THE GENERATOR. INSTEAD, EDIT THE INHERITED CLASS (${jClass.as3Type.name}.as).
 */

package ${jClass.as3Type.packageName} {
<%
    ///////////////////////////////////////////////////////////////////////////////
    // Write Import Statements.

    for (as3Import in as3Imports) { %>
import ${as3Import};<%
    }

    ///////////////////////////////////////////////////////////////////////////////
    // Write Class Declaration. %>

public class ${jClass.as3Type.name}Base<%

    boolean implementsWritten = false;
    if (jClass.hasSuperclass()) {
%> extends ${jClass.superclass.as3Type.name}<%
    } else {
%> extends RemoteObject<%

        implementsWritten = true;
    }
%> {<%

///////////////////////////////////////////////////////////////////////////
// Write private "initialized?" flag declaration. %>

    private static const logger:ILogger = Log.getLogger(getQualifiedClassName(${jClass.as3Type.name}).replace("::", "."));
    private var _initRemote:Boolean = false;
<%
    ///////////////////////////////////////////////////////////////////////////
    // Write Constructor
%>
    public function ${jClass.as3Type.name}Base() {
        super();
    }<%

    ///////////////////////////////////////////////////////////////////////////
    // Initializator. (was: C'tor.) %>

    private function initRemote():void {
        destination = "${jClass.destinationName}";
        channelSet = new ChannelSet();
        channelSet.addChannel(ServerConfig.getChannel("${jClass.channelName}"));
        _initRemote = true;
    }<%

    ///////////////////////////////////////////////////////////////////////////
    // Write Methods.

    for (jMethod in jClass.methods) { %>

    public function ${jMethod.name}(<%
        String[] names = jMethod.getAs3ParameterNames();
        int count = 0;
        for (pType in jMethod.getAs3ParameterTypes()) {
%>${names[count]}:${pType.name}, <%
            count++;
        }
        count = 0;
%>responder:IResponder = null):AsyncToken {
        if (!_initRemote) {
            initRemote();
        }

        var asyncToken:AsyncToken = getOperation("${jMethod.name}").send(<%
        for (pType in jMethod.getAs3ParameterTypes()) {
            if (count > 0) {
%>, <%
            }
%>${names[count]}<%
            count += 1;
        }
        count = 0;
%>);

        if (responder) {
            asyncToken.addResponder(responder);
        }

        if (Log.isDebug()) {
            logger.debug("Method <${jMethod.name}> invoked with parameters <%
        for (pType in jMethod.getAs3ParameterTypes()) {
            if (count > 0) {
%>, <%
            }
%><{${count}}><%
            count += 1;
        }
        count = 0;
%>"<%
        for (pType in jMethod.getAs3ParameterTypes()) {
%>, ${names[count]}<%
            count += 1;
        }
%>);
        }

        return asyncToken;
    }<%
    }

    ///////////////////////////////////////////////////////////////////////////
    // Write Result/Fail event managers. %>

    public function addOperationListener(op:Function, type:String, handler:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void {<%

    for (jMethod in jClass.methods) { %>
        if (op == this.${jMethod.name}) {
            this.getOperation("${jMethod.name}").addEventListener(type, handler, useCapture, priority, useWeakReference);
        }<%
    } %>
    }

    public function removeOperationListener(op:Function, event:String, handler:Function):void {<%
    for (jMethod in jClass.methods) { %>
        if (op == this.${jMethod.name}) {
            this.getOperation("${jMethod.name}").removeEventListener(event, handler);
        }<%
    } %>
    }
}
}